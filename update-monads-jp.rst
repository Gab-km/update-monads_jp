=================================================
Update モナドを使った F# における状態を持った計算
=================================================

:原文: `Stateful computations in F# with update monads - Tomas Petricek's blog <http://tomasp.net/blog/2014/update-monads/index.html>`_
:原著者: `Tomas Petricek <https://twitter.com/tomaspetricek>`_

F# においても、モナドについてのほとんどの議論は、Haskell で状態を扱うためのよく知られた標準的なモナドを見てみることから始まります。 *Reader* モナドはいくつかの読み取り専用な状態を伝播する方法を提供し、 *Writer* モナドは(手続き的に)ログのような値を生成できるようにし、 *State* モナドは読み取ったり変更したりすることができる状態を隠蔽します。

これらは Haskell では疑いようもなく便利なんですが、F# でも重要なものだと思った試しがありません。第一の理由が F# は状態と変化をサポートし、大抵、単に変更可能な状態を使う方が簡単です。第二の理由はそれらのモナド用に3つの異なるコンピュテーションビルダーを実装しなくちゃあいけないということです。これは明示的に計算に名前をつける、例えば ``async { ... }`` と書く必要があるという F# のスタイルにあまりうまく合いません。(`The F# Computation Zoo の論文についての最近のブログ記事 <http://tomasp.net/blog/2013/computation-zoo-padl/>`_ も参照してください)

12月にタリン大学を訪れた時(私をホストしてくれた James Capman、Juhan Ernits そして Tarmo Uustalu に感謝を！)、 `Update monads の論文 <http://cs.ioc.ee/~tarmo/papers/types13.pdf>`_ で Danel Ahman と Tarmo Uustalu による *update monads* の研究成果を見つけましたが、それは単一の抽象で *Reader* 、 *Writer* そして *State* モナドをエレガントにまとめるものでした。

本記事で、私は F# で *Update モナド* のアイディアを実装します。Update モナドは state 上で完了した演算をキャプチャする *acts* によってパラメタライズされます。どういうことかというと、私たちはたった1つのコンピュテーション式 ``update { ... }`` を定義するだけで、前述した3種全ての計算を書くために使うことができる、ということです。

Update モナドの紹介
===================

Update モナドの定義を見る前に、私たちがひとまとめにしたい3つのモナドをレビューすると都合がいいですね。 `Update モナドの論文 <http://cs.ioc.ee/~tarmo/papers/types13.pdf>`_ はより詳細で、これらを F# で実装した別のチュートリアルも見つけることができます ― では、型の定義だけ見てみることにしましょう:

.. code-block:: fsharp

  /// 与えられた読み取り専用の状態から、値を生成する
  type Reader<'TState, 'T> = 'TState -> 'T
  /// 追加の状態と一緒に値を生成する
  type Writer<'TState, 'T> = 'TState * 'T
  /// 与えられた状態に対し、新しい状態と値を生成する
  type State<'TState, 'T>  = 'TState -> 'TState * 'T

この定義を見たら、 *Reader* と *Writer* はどちらも *State* に何らかの特徴が欠けたバージョン ― Reader は新しい状態を生成せず、Writer は前の状態を受け取らない ― のように見えるでしょう。

どれかを対象外にできるようなパラメータ化されたコンピュテーション型をどのように定義したらよいでしょうか？ *Update モナド* のアイディアはまさにシンプルです。トリックは2つの異なる型を受け取ることです ― 1つは読み取りできる *状態* を表し、もう1つはどのように状態を変更するか特定する *更新* を表します:

.. code-block:: fsharp

  /// Update モナドを表す - 与えられた状態に対し、
  /// 値とその状態に適用される更新を生成する
  type UpdateMonad<'TState, 'TUpdate, 'T> =
    UM of ('TState -> 'TUpdate * 'T)

F# の実装をもうちょっといい感じにするために、これは型エイリアスとしてではなく、``UM`` というラベルを持った新しい型(これにより、推論された型がその定義名ではなく、常に ``UpdateMonad`` を型名として使うことになります)として定義されています。

これがちゃんと動くようにするため、私たちは状態と更新を表す型に対していくつかの演算も必要となります。特に、私たちが必要なのは以下のものです:

* 何の更新も適用されないことを表す **更新の単位元**
* ある状態における複数の更新を結合し、１つの更新にする **更新の結合**
* 状態と更新を受け取って状態に更新を適用し、結果として新しい状態を生成する **適用**

より形式的な用語だと、更新の型は(単位元と結合を持つ)モノイドである必要があります。この論文では、2つの型(集合)と演算を一緒にしたものを *act* と呼び、 ∘ を単位元、 ⊕ を合成、そして ↓ を適用として (**S**,(**P**,∘,⊕),↓) として定義されています。

  ネーミングについての注釈

  最後のケースで、私は元の論文とは異なるネーミングを使っています。この論文では、状態 **s** に更新 **u** を適用することを **s↓u** と書いています。 **"↓u"** の部分を状態を変化させる *作用* として見ることができるので、著者は *action* という名前を使っています。私は全体(部分適用された操作)よりもこの演算 **↓** により言及しているので、代わりに *apply* を使おうと思います。

F# で Update モナドを実装する
=============================

F# でこのアイディアを実装するために、私たちは `静的メンバー制約 <http://msdn.microsoft.com/en-us/library/dd233203.aspx>`_ を使うことができます。F# の静的メンバー制約についてご存じない場合は、ダックタイピングのようなもの(または軽量な型クラス)だと思っておくといいでしょう。もしある型がとあるメンバーを定義していれば、コードがちゃんとコンパイルと実行ができ、そうでなければコンパイル時エラーが発生します。私たちはユーザーに ``State`` と ``Update`` を表す2つの型をそれぞれ定義するように求めます。 ``Update`` 型は3つの演算を定義する必要があります。抽象的な定義(ちゃんとした F# のコードではありません)はこのようになります:

.. code-block:: fsharp

  type State
  type Update =
    static Unit    : Update
    static Combine : Update * Update -> Update
    static Apply   : State * Update -> State

静的メンバー制約によるメンバー呼び出しは、全然簡単ではありません(その機能は主にジェネリックな数値型のコードのような用途のライブラリを実装する方々に利用されます)。しかし、(明示的に、または型インターフェイスを通じて特定された)型に対応した演算を呼び出すインライン関数(``unit`` 、 ``++`` および ``apply``)を定義することができるのがこのアイディアなのです。

もし F# に馴染みがないのであれば、 ``unit`` 関数、 ``apply`` 関数、 ``++`` 演算子があるよということだけ覚えておいて、この定義は気軽に飛ばして構いません:

.. code-block:: fsharp

  /// ^S 型の 'Unit' プロパティの値を返す
  let inline unit< ^S when ^S :
      (static member Unit : ^S)> () : ^S =
    (^S : (static member Unit : ^S) ())

  /// ^S 型の値のペアに対する Combine 演算を呼び出す
  let inline (++)< ^S when ^S :
      (static member Combine : ^S * ^S -> ^S )> a b : ^S =
    (^S : (static member Combine : ^S * ^S -> ^S) (a, b))

  /// 状態と更新のペア ^S * ^U に対する Apply 演算を呼び出す
  let inline apply< ^S, ^U when ^U :
      (static member Apply : ^S * ^U -> ^S )> s a : ^S =
    (^U : (static member Apply : ^S * ^U -> ^S) (s, a))

Update モナドで遊び始める前に私たちがするべきことの最後は、モナド的な演算を実装することです。F# では、 *コンピュテーションビルダー* ― ``Bind`` と ``Return`` という演算(他のいくつかも後ほど見てみましょう)を持った型 ― を定義することで達成されます。そしてコンパイラは自動的に ``update.Return`` 演算と ``update.Bind`` 演算を使っている ``update { .. }`` ブロックを翻訳します。

コンピュテーションビルダーはメンバーを持った普通のクラスです。私たちは静的メンバー制約とインライン関数を使っているため、私たちはメンバーにもまた ``inline`` を付ける必要があります。

.. code-block:: fsharp

  type UpdateBuilder() =
    /// 特定の値と一緒に 'unit' を使って得た空の更新を返す
    member inline x.Return(v) : UpdateMonad<'S, 'U, 'T> =
      UM (fun s -> (unit(),v))

    /// 2つの Update モナドの計算を合成する
    member inline x.Bind(UM u1, f:'T -> UpdateMonad<'S, 'U, 'R>) =
      UM (fun s ->
        // 最初の更新 'u1' を取得するために最初の計算を実行し、
        // 2つ目の計算を取得するために 'f' を実行する
        let (u1, x) = u1 s
        let (UM u2) = f x
        // 元の状態に 'u1' を適用し、2つ目の計算を実行して
        // 状態と更新を合わせた結果を返す
        let (u2, y) = u2 (apply s u1)
        (u1 ++ u2, y)

  /// update { .. } ブロックを定義する
  /// コンピュテーションビルダーのインスタンス
  let update = UpdateBuilder()

``Return`` 演算の実装は本当にシンプルです ― 特定の値を返し、更新のモノイドの単位元を取得するために unit() を呼び出します ― その結果、私たちは状態を更新することなく値を返す計算を取得します。

``Bind`` メンバーはもっと興味深いです ― 値 ``x`` と更新 ``u1`` を返す最初の計算を実行します。2番目の計算は更新された状態に対して実行される必要があるので、更新を反映した新しい状態を計算するために ``aply s u1`` を使います。2番目の計算を実行したあと、値 ``y`` と2つ目の更新 ``u2`` を最終結果として取得します。計算結果は ``u1 ++ u2`` を用いて2つの更新を結合します。

これは実際どのように機能するんでしょうか？(Update モナドの特別なケースである)Reader と Writer モナドを確認することで始めてみましょう。

Readerモナドの実装
==================

Readerモナドはいくつかの状態を保持しますが、それらを更新する術をもちません。Updateモナドの文脈で言うならば、いくつか状態は存在するものの、更新を行うモノイド自明です - 原則的には単に ``Unit`` を更新の型として用いればいいということになります。このことは、型を見ればわかります -Readerモナドの方は ``'TState -> T`` となっています-。Updateモナドに対応する構造にするため、同様の意味を持つ型として ``'TState -> unit * 'T`` を用いることができます。

------------------
Readerの状態と更新
------------------

実際の所、必要な静的メンバを提供できるように、さらに更新のための型を定義する必要があります。 ``NoUpdate`` 1ケースのみを持つ判別共用体を使いましょう。

.. code-block:: fsharp

  /// Readerの状態は 'int'
  type ReaderState = int
  /// 更新用の自明なMonoid
  type ReaderUpdate =
    | NoUpdate
    static member Unit = NoUpdate
    static member Combine(NoUpdate, NoUpdate) = NoUpdate
    static member Apply(s, NoUpdate) = s

``ReaderUpdate`` に関わる操作で興味深いものはありません。 ``unit`` も ``combine`` も単純に取りうるただひとつの値を返すだけですし、 ``apply`` 操作は状態を変更なく返すだけです。

-------------------------
Readerモナド プリミティブ
-------------------------

次に、プリミティブな操作として、状態を読み取り、（読み取り専用な値を受け取る）Readerモナドを用いて実装された計算を実行するという操作を行うものを定義します。以下のようになります。

.. code-block:: fsharp

  /// 現在の状態（int）を読み取り、それを'int'として返す
  let read = UM (fun (s:ReaderState) ->
    (NoUpdate, s))
  /// 計算を実行し結果を返す
  let readRun (s:ReaderState) (UM f) = f s |> snd

計算の型を確認すると（マウスを ``read`` の上にホバーさせてみてください）、パラメータ化されたUpdateモナド型になっているのがわかります。 ``read`` プリミティブは ``UpdateMonad<ReaderState, ReaderUpdate, ReaderState>`` 型です。これは ``ReaderState`` と ``ReaderUpdate`` を （計算の詳細を指定する） *act* として用い、実行時には ``ReaderState`` を生成するようなupdateモナドを定義したことを意味します。

-------------------------------------
Reader コンピュテーション式のサンプル
-------------------------------------

これで ``update{ .. }`` ブロックを、 ``read`` プリミティブとともに使い、不変状態を読み取ることができるコンピュテーション式を記述することができます。以下に示す基本的な例では、状態を読み取り、1を加算し（ ``demo1`` ）、さらにもう一度1を加算しています（ ``demo2`` ）。

.. code-block:: fsharp

  /// stateに1加算したものを返す
  let demo1 = update {
    let! v = read
    return v + 1 }
  /// demo1に1加算したものを返す
  let demo2 = update {
    let! v = demo1
    return v + 1 }

  // demo2を40で行う
  demo2 |> readRun 40

コードを実行すると、結果は42となるでしょう。このアプローチの興味深い点は、2つの型しか定義する必要がなかった、ということです。 ``update { .. }`` コンピュテーション式は、全てのUpdateモナドに対してちゃんと動作しますので、コンピュテーション式ビルダを"タダで"使うことができてしまいます。それでいながらも、パラメタ化の恩恵により、この計算は 不変の状態 -変更する手段が全くない- を、まさに表現しているのです。

Writer モナドの実装
===================

Reader モナドと同様に、Writer モナドは Update モナドのシンプルで特別なケースに過ぎません。今回は、 *state* が自明であること、および全ての興味深いことが update の中で起こっています。普通の Writer モナドの型は ``'TState * 'T`` ですので、これを Update モナドの特別なケースにしたいのであれば、私たちはこの型を ``unit -> 'TState * 'T`` として定義できます。

-------------------
Writer の状態と更新
-------------------

複数の下位の計算の状態を合成することが出来るように、状態は(単位元と合成を持った)モノイドである必要があります。以下の例は具体的な例としてリストを使っています。私たちは ``'TLog`` の値を保持し、結果としてそのリストを返す(Writer)モナドを定義します(より一般的には、私たちはリストの代わりに任意のモノイドを定義することが出来ます):

.. code-block:: fsharp

  /// Writer モナドは読み込み可能な状態を持たない
  type WriterState = NoState

  /// Writer モナドの更新がリストを形成する
  type WriterUpdate<'TLog> =
    | Log of list<'TLog>
    /// 空のログを返す(モノイドの単位元)
    static member Unit = Log []
    /// 2つのログを結合する(モノイドの演算)
    static member Combine(Log a, Log b) = Log(List.append a b)
    /// 状態に更新を適用することはその状態に影響を与えない
    static member Apply(NoState, _) = NoState

Writer モナドは先の Reader モナドに対して(いくぶん形式的でない点で)2つの面を見せます。(読み取り可能な)状態は常に空で ``NoState`` という値で表現されていますが、ここでは全ての興味深い側面は ``WriterUpdate`` 型―この型は計算によって生成された値のリストです。Writer モナドの更新はモノイドを成す必要があります―に捉えられており、私たちはすべてのログの値を連結したリストを使います。他のモノイド(例えば、最後に生成した値を保持する)を実装する定義に簡単に変更できます。

---------------------------
Writer モナドのプリミティブ
---------------------------

前の例と同様に、2つのプリミティブー1つはログに新しい要素を追加するもの(Writer モナドの ``write``)、もう1つは計算を実行し結果とログを抽出するものーが必要です:

.. code-block:: fsharp

  /// ログに特定の値を書き込む
  let write v = UM (fun s -> (Log [v], ()))
  /// "Writer モナドの計算"を実行し、最終結果と
  /// 一緒にログを返す
  let writeRun (UM f) = let (Log l, v) = f NoState in l, v

``writer`` 関数は更新として特定の値 ``Log [v]`` を含む単独のリストを作り、計算の結果として単位元を返します。他の計算と合成させた時、更新は連結され、 ``(Log l, v)`` の中にあるリスト ``l`` の一部になるため、 ``writerRun`` 関数の中でアクセス可能になります

---------------------
Writer の計算サンプル
---------------------

新しい定義を使った計算のサンプルを見てみましょうー(実践的な F# プログラミングの視点から)特筆すべきことは、ちょうど前の例のように ``update { .. }`` ブロックの中に計算をラップしたことです。しかし今回、20とそれから10をログに書き込むために ``write`` プリミティブを使い、F# コンパイラは私たちが ``WriterState`` と ``WriterUpdate`` 型を使っていることを正しく推論します:

.. code-block:: fsharp

  /// '20' をログに書き"world"を返す
  let demo3 = update {
    do! write 20
    return "world" }
  /// 'demo3'を呼び出し、10をログに書き込む
  let demo4 = update {
    let! w = demo3
    do! write 10
    return "Hello " + w }

  /// ログにある20と10と一緒に"Hello world"を返す
  demo4 |> writeRun

このコードを実行すると、 ``demo3`` の計算が最初に 20 をログに書き込み、 ``demo4`` で書き込まれた値 10 が(``WriterUpdate.Combine`` を呼び出す ``++`` 演算子を使って)合成されます。

より豊かな計算の構築
====================

私が `以前のブログ投稿 <http://tomasp.net/blog/2013/computation-zoo-padl>`_ と `PADL 2014 の論文 <http://tomasp.net/academic/papers/computation-zoo/>`_ で強調していた F# のコンピュテーション式についてキーとなるものの1つは、コンピュテーション式がリソース管理(``use`` キーワード)や、例外処理、ループ(``for`` と ``while``)を含めた豊かな構文をもたらすということです－シンプルな言葉で言うと、これは普通の F# の構文そのままです。

今までのところ、これらを何一つ Update モナドで使ったことがありません。これら全ての追加構造は(作者が最も都合の良い方法でそれらを定義できるように)コンピュテーションビルダーで提供されるべきものです。(F# 用の)Update モナドについてもっとも素晴らしいことは、私たちには単一のコンピュテーションビルダーがあり、そのためより豊かな構文を可能にするためにたくさんの演算を定義できることです。

以下のスニペットは先に定義した ``UpdateBuilder`` をより多くの演算で拡張します。もし詳細に興味がなければ、次のセクションに飛んで構いません。キーとなるアイディアは、これは一度だけ書けばよいということです！

.. code-block:: fsharp

  /// 追加の構文をサポートするために UpdateBuilder を拡張する
  type UpdateBuilder with
    /// ユニットを返すモナド的計算を表現する
    /// (例えば、'if' 計算で 'else' 節を省略できるようになります)
    member inline x.Zero() = x.Return(())

    /// (制御されていない)副作用のある計算を遅らせる
    member inline x.Delay(f) = x.Bind(x.Zero(), f)

    /// 1番目が結果を持たない(ユニットの値を返す)2つの計算を
    /// 順番に合成する
    member inline x.Combine(c1, c2) = x.Bind(c1, fun () -> c2)

    /// もう一つの計算を返すために'return!' キーワードを利用可能にする
    member inline x.ReturnFrom(m : UpdateMonad<'S, 'P, 'T>) = m

    /// 関数 'f' で指定された計算の最後でリソース 'r' が破棄される
    /// ことを保証する
    member inline x.Using(r,f) = UM(fun s ->
      use rr = r in let (UM g) = f rr in g s)

    /// 'for' ループをサポートする－'sq' の各要素に対し 'f' を実行する
    member inline x.For(sq:seq<'V>, f:'V -> UpdateMonad<'S, 'P, unit>) =
      let rec loop (en:System.Collections.Generic.IEnumerator<_>) =
        if en.MoveNext() then x.Bind(f en.Current, fun _ -> loop en)
        else x.Zero()
      x.Using(sq.GetEnumerator(), loop)

    /// 'while' ループをサポートする－条件 't' が成り立つまで 'f' を実行する
    member inline x.While(t, f:unit -> UpdateMonad<'S, 'P, unit>) =
      let rec loop () =
        if t() then x.Bind(f(), loop)
        else x.Zero()
      loop()

これらの演算についてもっと詳しい内容は `F# Computation Zoo の論文 <http://tomasp.net/academic/papers/computation-zoo/>`_ や `F# 言語仕様 <http://fsharp.org/about/index.html#specification>`_ で見つけることができます。実際、この定義はほぼ F# の仕様からのサンプルに従っています。コメントしておく価値があることとしては、全てのメンバーが ``inline`` としてマークされており、これにより *静的メンバー制約* が使えるようになり、(*update* と *state* 型のペアとして定義された)どんな Update モナドでも動作するコードが書けるようになります。

Writer コンピュテーションを使った自明な例を見てみましょう:

.. code-block:: fsharp

  /// 1 から 10 までの数字をログに書き込む
  let logNumbers = update {
    for i in 1 .. 10 do
      do! write i }

予想通り、 ``writeRun`` を使った計算を実行すると、結果は 1 から 10 までの数字のリストとユニット値を持つタプルとなります。この計算は明示的にリターンしていないので、 ``Zero`` メンバーが自動的に使われます。

Stateモナドの実装
=================

興味深いことに、通常のStateモナドはUpdateモナドの特別系 *ではありません* 。しかし、同様の機能 - 読み書き可能な状態を伴った計算 - を実装した計算を定義することはできます。

----------
状態と更新
----------

この最後の例では、 *状態* を表す型 ``State`` と *更新* を表現する型 ``Update``  両方が、意味のある役割を持つことになります。それらの型を自身が保持している値に対してジェネリックにします。 ``State`` は単に含んでいる値（現在の状態）のラッパーです。 ``Update`` は2種類 - 空の更新（何もしない）と状態を設定する更新  - を取り得ます。

.. code-block:: fsharp

  /// 型'Tの状態をラップします
  type StateState<'T> = State of 'T

  /// 型'Tの状態に対する更新を表します
  type StateUpdate<'T> =
    | Set of 'T | SetNop
    /// 空の更新 - 何も状態を変更しません
    static member Unit = SetNop
    /// 更新の結合 - 最新の（最も右にある） 'Set'更新を返します
    static member Combine(a, b) =
      match a, b with
      | SetNop, v | v, SetNop -> v
      | Set a, Set b -> Set b
    /// 状態に対して更新を適用します - 'Set'更新が状態を変更します
    static member Apply(s, p) =
      match p with SetNop -> s | Set s -> State s

この定義は前の2つに比べるとより興味深いものとなっています、なぜなら *状態* と *更新* の間にいくつかの相互作用があるからです。特に、更新が ``Set v`` （現在の状態を新しいもので置き換えようとします） の時には、 ``Apply`` メンバは元とは異なる状態を返します。 ``Unit`` メンバについては、 単に元の状態を保持しておくという ``SetNop`` の更新が必要になります。（ですのでこの場合は ``Apply`` はただ単に元の値を返します。）

もう一つの特筆すべき点は、 ``Combine`` 操作 - 2つの更新（両方とも空の更新かも知れませんし通常の更新かもしれません）を受け取り一つの更新を返します - です。合成 ``a1 ++ a2 ++ .. ++ an`` を状態更新のシーケンス（ ``Set`` でも ``SetNope`` でも構いません ）として読み取った場合、 ``Combine`` 操作はシーケンス中の最後の ``Set`` 更新（一つも ``Set`` 更新がない場合は ``SetNop`` ）を返します。言い換えると、シーケンス全体の中での最後の状態を設定するような更新を構築するのです。

------------------------
State モナドプリミティブ
------------------------

さあ、型の定義はできましたので、通常のプリミティブを追加するのはかなり簡単になります。

.. code-block:: fsharp

  /// 指定された値に状態を設定する
  let set s = UM (fun _ -> (Set s,()))
  /// 現在の状態を取得する
  let get = UM (fun (State s) -> (SetNop, s))
  /// 初期状態を設定して計算を実行する
  let setRun s (UM f) = f (State s) |> snd

``set`` 操作は一般的なStateモナドのそれとは少し違います。状態を無視し、新しい状態を設定するための計算を表す *更新* を構築します。 ``get`` オペレーションは状態を読み取ってそれを返します - ただし何も変更しない場合には、更新として ``SetNop`` を返します。

--------------------------
状態を持った計算のサンプル
--------------------------

ここまで読んできた方なら、次の例がどんな風になるのか予想できるでしょう！もう一度 ``update { .. }`` コンピュテーション式を使います。今回は、 ``demo5`` という、状態をインクリメントし ``demo6`` のループの中から呼ぶコンピュテーション式を定義します。

.. code-block:: fsharp

  /// 状態を1ずつインクリメントする
  let demo5 = update {
    let! v = get
    do! set (v + 1) }
  /// demo5をループの中で反復して呼び
  /// 最後の状態を返す
  let demo6 = update {
    for i in 1 .. 10 do
      do! demo5
    return! get }
  // サンプルを初期状態 0 で実行させる
  demo6 |> setRun 0

コードを実行すると、予想通り10という結果を得ます - ゼロから始まり、その状態を10回インクリメントしたわけです。 我々は ``UpdateBuilder`` の定義を拡張しましたので（前の章で行いました）,
いくつかの素敵な特典にタダ乗りで来ています - ``for`` ループを使うことや、（ ``demo5`` のように）ただ状態を変更したいだけの際には、明示的に ``return`` を書かなくても計算を記述することができるのです。

結び
====

Haskellのバックグラウンドを持つ人々がF#をみるとき、F#がモナドを用いて多態的にコードを書かせてくれず、コンピュテーション式が、 ``async { .. }`` のように常に計算の方を明示的に示さなければいけないことを、よく嫌います。これには良い理由があると私は考えていて、それらの幾つかについては `最近のBlog投稿とPADAの論文 <http://tomasp.net/blog/2013/computation-zoo-padl>`_ で説明を試みています。

結果から言えば、Reader・Writer・Stateの各モナドをF#で使うのは、常に多少面倒を伴います。このBlog投稿では、 *Updateモナド* と名付けられた、3つの状態に関連したモナドを一つの型に統合する最近のアイデア （詳しくは `オリジナルの論文 (PDF) <http://cs.ioc.ee/~tarmo/papers/types13.pdf>`_ を読んで下さい ） のF#実装を見ました。これはF#上で非常に上手く動きます - たった一つのコンピュテーションビルダーを、状態に関連した全ての計算用に定義することができ、実際の状態に関連したモナドの定義を、2つの単純な型を決めるだけでできてしまうのです。私はこのアプローチを、Readerモナドと、ログに有用なWriterモナドと、Stateモナド（状態を保持し変更できます）を定義するのに用いました。

私の考えでは、UpdateモナドをHaskellの標準的なライブラリやプログラミングスタイルに取り込むのは、歴史的な理由によりトリッキーになるでしょう。しかしながら、純粋関数型プログラミングをより簡単にしようとしているF#のライブラリにとっては、Updateモナドは取りうる道の一つではないかと思っています。

-------------------------------------------------------

----------------------
翻訳者 / translated by
----------------------

* `@Gab-km <https://github.com/Gab-km>`_
* `@posaunehm <https://github.com/posaunehm>`_
