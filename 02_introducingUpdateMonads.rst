Update モナドの紹介
-------------------

Update モナドの定義を見る前に、私たちがひとまとめにしたい3つのモナドをレビューすると都合がいいですね。 `Update モナドの論文 <http://cs.ioc.ee/~tarmo/papers/types13.pdf>`_ はより詳細で、これらを F# で実装した別のチュートリアルも見つけることができます ― では、型の定義だけ見てみることにしましょう:

.. code-block:: fsharp

  /// 読み取り専用の状態を提供し、値を生成する
  type Reader<'TState, 'T> = 'TState -> 'T
  /// 追加の状態と一緒に値を生成する
  type Writer<'TState, 'T> = 'TState * 'T
  /// 状態を提供し、新しい状態と値を生成する
  type State<'TState, 'T>  = 'TState -> 'TState * 'T

この定義を見たら、 *Reader* と *Writer* はどちらも *State* に何らかの特徴が欠けた ― Reader は新しい状態を生成せず、Writer は前の状態を受け取らない ― バージョンのように見えるでしょう。

どれかを対象外にできるようなパラメータ化されたコンピュテーション型をどのように定義したらよいでしょうか？ *Update モナド* のアイディアはまさにシンプルです。トリックは2つの異なる型を受け取ることです ― 1つは読み取りできる *状態* を表し、もう1つはどのように状態を変更するか特定する *更新* を表します:

.. code-block:: fsharp

  /// Update モナドを表す - ある状態に対し、値とその状態に
  /// 適用される更新を生成する
  type UpdateMonad<'TState, 'TUpdate, 'T> =
    UM of ('TState -> 'TUpdate * 'T)

F# の実装をもうちょっといい感じにするために、これは型エイリアスとしてではなく、``UM`` とラベルされた新しい型(これは推論された型がその定義ではなく、常に ``UpdateMonad`` という名前を型に使うことを確認します)として定義されています。

これを上手く動かすため、私たちは状態と更新を表す型にいくつかの演算も必要とします。特に、私たちが必要なのは以下のものです:

Unit update
  何の更新も適用されないことを表します。
Composition of updates
  ある状態における複数の更新を結合し、１つの更新にします。
Application
  状態と更新を受け取って状態に更新を適用し、結果として新しい状態を生成します。

より形式的な用語だと、更新の型は(単位元と結合を持つ)モノイドである必要があります。この論文では、2つの型(集合)と演算を一緒にしたものを *act* と呼び、 ∘ を単位元、 ⊕ を合成、そして ↓ を適用として (S,(P,∘,⊕),↓) として定義されています。

  ネーミングについての注釈

  最後のケースで、私は元の論文とは異なるネーミングを使っています。この論文では、状態 **s** に更新 **u** を適用することを **s↓u** と書いています。 **"↓u"** の部分を状態を変化させる *作用* として見ることができるので、著者は *action* という名前を使っています。私は全体(部分適用された操作)よりもこの演算 *↓* により言及しているので、代わりに *apply* を使おうと思います。
